<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on shibadog site</title>
		<link>https://pages.shibadog.net/posts/</link>
		<description>Recent content in Posts on shibadog site</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>ja-jp</language>
		<lastBuildDate>Wed, 17 May 2023 00:00:00 +0900</lastBuildDate>
		<atom:link href="https://pages.shibadog.net/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>spring boot 3 trace</title>
			<link>https://pages.shibadog.net/posts/008_survery_results/</link>
			<pubDate>Wed, 17 May 2023 00:00:00 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/008_survery_results/</guid>
			<description>背景 spring boot3になってからtraceの構成が変わった。
sleuth から micrometer observationを使う用に代わり、opentelemetryが入ってきて関係性が変わったのでそれを把握したい。
micrometer observationの解説は優秀なブログがすでにあるのでそちらに任せることにする。
https://programacho.com/blog/a10b96ec9d79/
ここでは、このmicrometerの裏側を把握することを目的とする。
全体感から見た各種ライブラリの役割 ▲ なにかのdiagramのルールにのっとって書いているわけではなく、雰囲気で矢印と図形の形を変えている。
意味はあるが公のルールではないのでご注意。
tracer layerの詳細 この領域はトレーサー層と呼ぶらしい。
ここは、exporter（braveではreporter）を使って実際のトレース情報を伝送する部分の実装であったり、アプリケーション間のトレース情報をつなぐための処理を行う実装が存在する。
braveはもともとのspring cloudに存在する実装であり、zipkinのb3ヘッダのみに対応している。
opentelemetryでは、opentelemetryが定義する伝送プロトコル（なんだっけ？）とb3のどちらにも対応しており、ここをpropagatorと呼んでおり差し替え可能となっている。
 w3c → W3CTraceContextPropagator b3 → B3Propagator  opentelemetryを使った場合のexporter layer詳細 Opentelemetryに対応したトレース参照用のツールはいくつか存在する。
これ以外にも、上記zipkinの例から以下のような構造になっていることが伺える。
参考資料のmakingさんの資料にある通り、spring boot 3.0.Xまでは、exporterのauto configに対応している（つまり何もBean登録しなくても設定だけで使えるやつ）のはzipkinとwavefrontのみとなっている。
しかし、opentelemetry自体はいろいろなexporterに対応しており、自力でBean登録をすることで異なるサービスにtraceを伝送することが可能になっている。
braveを使った場合のexporter layer(reporter)詳細 tracerをopentelemetryではなく従来のbraveを選択することも可能となっている。
この場合でも伝送先を切り替えることが可能となっている。
Opentelemetryに対応しているElastic APMに入れてみる 本リポジトリでは、前章でまとめた依存のうち以下のような組み合わせでアプリケーションを作成している。
 tracer layer -&amp;gt; opentelemetry exporter layer -&amp;gt; opentelemetry  tracerの記録先は Elastic APMを利用している。
詳しくは ../../pom.xml を参照いただきたいが、traceにかかわる依存は以下の通り。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;micrometer-tracing-bridge-otel&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.opentelemetry&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;opentelemetry-exporter-otlp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; spring bootに関しては、3.</description>
			<content type="html"><![CDATA[<h2 id="heading">背景</h2>
<p>spring boot3になってからtraceの構成が変わった。</p>
<p>sleuth から micrometer observationを使う用に代わり、opentelemetryが入ってきて関係性が変わったのでそれを把握したい。</p>
<p>micrometer observationの解説は優秀なブログがすでにあるのでそちらに任せることにする。</p>
<p><a href="https://programacho.com/blog/a10b96ec9d79/">https://programacho.com/blog/a10b96ec9d79/</a></p>
<p>ここでは、このmicrometerの裏側を把握することを目的とする。</p>
<h2 id="heading-1">全体感から見た各種ライブラリの役割</h2>
<p>▲ なにかのdiagramのルールにのっとって書いているわけではなく、雰囲気で矢印と図形の形を変えている。<br>
意味はあるが公のルールではないのでご注意。</p>
<p><img src="./dependency-overview.drawio.svg" alt="依存の関係性概要"></p>
<h3 id="tracer-layer">tracer layerの詳細</h3>
<p>この領域はトレーサー層と呼ぶらしい。<br>
ここは、exporter（braveではreporter）を使って実際のトレース情報を伝送する部分の実装であったり、アプリケーション間のトレース情報をつなぐための処理を行う実装が存在する。</p>
<p>braveはもともとのspring cloudに存在する実装であり、zipkinのb3ヘッダのみに対応している。</p>
<p>opentelemetryでは、opentelemetryが定義する伝送プロトコル（なんだっけ？）とb3のどちらにも対応しており、ここをpropagatorと呼んでおり差し替え可能となっている。</p>
<ul>
<li>w3c → W3CTraceContextPropagator</li>
<li>b3 → B3Propagator</li>
</ul>
<p><img src="./tracer-layer-dependency.drawio.svg" alt="tracer layer"></p>
<h3 id="opentelemetryexporter-layer">opentelemetryを使った場合のexporter layer詳細</h3>
<p>Opentelemetryに対応したトレース参照用のツールはいくつか存在する。</p>
<p>これ以外にも、上記zipkinの例から以下のような構造になっていることが伺える。</p>
<p><img src="./expoter-layer-dependency.drawio.svg" alt="exporter layer"></p>
<p>参考資料のmakingさんの資料にある通り、spring boot 3.0.Xまでは、exporterのauto configに対応している（つまり何もBean登録しなくても設定だけで使えるやつ）のはzipkinとwavefrontのみとなっている。</p>
<p>しかし、opentelemetry自体はいろいろなexporterに対応しており、自力でBean登録をすることで異なるサービスにtraceを伝送することが可能になっている。</p>
<h3 id="braveexporter-layerreporter">braveを使った場合のexporter layer(reporter)詳細</h3>
<p>tracerをopentelemetryではなく従来のbraveを選択することも可能となっている。<br>
この場合でも伝送先を切り替えることが可能となっている。</p>
<p><img src="./reporter-layer-dependency.drawio.svg" alt="reporter layer"></p>
<h2 id="opentelemetryelastic-apm">Opentelemetryに対応しているElastic APMに入れてみる</h2>
<p>本リポジトリでは、前章でまとめた依存のうち以下のような組み合わせでアプリケーションを作成している。</p>
<ul>
<li>tracer layer -&gt; opentelemetry</li>
<li>exporter layer -&gt; opentelemetry</li>
</ul>
<p>tracerの記録先は Elastic APMを利用している。</p>
<p>詳しくは <code>../../pom.xml</code> を参照いただきたいが、traceにかかわる依存は以下の通り。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">
		<span style="color:#f92672">&lt;dependency</span><span style="color:#f92672">&gt;</span>
			<span style="color:#f92672">&lt;groupId</span><span style="color:#f92672">&gt;</span>io.micrometer<span style="color:#f92672">&lt;/groupId&gt;</span>
			<span style="color:#f92672">&lt;artifactId</span><span style="color:#f92672">&gt;</span>micrometer-tracing-bridge-otel<span style="color:#f92672">&lt;/artifactId&gt;</span>
		<span style="color:#f92672">&lt;/dependency&gt;</span>

		<span style="color:#f92672">&lt;dependency</span><span style="color:#f92672">&gt;</span>
			<span style="color:#f92672">&lt;groupId</span><span style="color:#f92672">&gt;</span>io.opentelemetry<span style="color:#f92672">&lt;/groupId&gt;</span>
			<span style="color:#f92672">&lt;artifactId</span><span style="color:#f92672">&gt;</span>opentelemetry-exporter-otlp<span style="color:#f92672">&lt;/artifactId&gt;</span>
		<span style="color:#f92672">&lt;/dependency&gt;</span>

</code></pre></div><p>spring bootに関しては、3.0.x系であるため、そのままではopentelemetry exporterのauto configに対応していない。</p>
<p>このため、自分でBean登録を行った。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Bean</span>
    SpanExporter <span style="color:#a6e22e">otlpHttpSpanExporter</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> OtlpHttpSpanExporter<span style="color:#f92672">.</span><span style="color:#a6e22e">builder</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">setEndpoint</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;http://localhost:8200/v1/traces&#34;</span><span style="color:#f92672">)</span> <span style="color:#75715e">// &lt;- elastic apm のエンドポイント
</span><span style="color:#75715e"></span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">build</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="heading-2">参考資料</h2>
<h3 id="trace">Traceについての公式ドキュメントの記述</h3>
<p><a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/htmlsingle/#actuator.micrometer-tracing">https://docs.spring.io/spring-boot/docs/3.0.5/reference/htmlsingle/#actuator.micrometer-tracing</a></p>
<h3 id="making">makingさんの最強資料</h3>
<p><a href="https://bit.ly/springboot2023">https://bit.ly/springboot2023</a></p>
]]></content>
		</item>
		
		<item>
			<title>spring boot vault</title>
			<link>https://pages.shibadog.net/posts/007_spring-vault/</link>
			<pubDate>Tue, 22 Sep 2020 14:52:00 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/007_spring-vault/</guid>
			<description>やってみた。
Spring Vault
VaultはHashiCorpのプロダクトで、クレデンシャル情報を保持するミドル。
Vaultはコマンドラインでクレデンシャル情報の設定・取得が可能だが、spring boot vaultを使って、Configurationとしてアプリケーションの設定を連携することができる。
spring cloud configと同様に、 bootstrap.properties でVaultへの接続情報を設定することで、読み込みを行うようだ。
application.yml を作成してそこからの設定値読み込みと同時に使用しても問題なく使えた。 (まぁ当たり前か。)
RabbitだのAWSだのElasticsearchだののクレデンシャル情報に対応していると記載されているところから、 bootstrap.properties で操作することで、対応するミドルウェアのクレデンシャル情報を通常の application.yml に設定するのと同様の状態で設定することができるようだ。
 どのへんでうれしさを感じるのだろうか？
環境変数で刺すようにするサービスブローカーとどう違うのか。。。？
よりアプリケーションに近い位置でクレデンシャルを設定できるので、良いような悪いような。
コンテナ運用の場合はコンテナ管理ミドルによって環境変数にさしてほしい気もする。
コンテナ管理ミドルを使わずに、手運用デプロイしているときにうれしいとか？
そんな状況で（クレデンシャル管理が）いる？
（そんなならば application.yml にべた書きしてもよいじゃないか）
K8Sな言葉がちょいちょい出てくるので何か想定する運用があるっぽい気もするけど、調べるの飽きてきたのでそろそろ終わる。</description>
			<content type="html"><![CDATA[<p>やってみた。</p>
<p><a href="https://spring.pleiades.io/guides/gs/vault-config/">Spring Vault</a></p>
<p><a href="https://www.vaultproject.io/">Vault</a>はHashiCorpのプロダクトで、クレデンシャル情報を保持するミドル。</p>
<p>Vaultはコマンドラインでクレデンシャル情報の設定・取得が可能だが、spring boot vaultを使って、Configurationとしてアプリケーションの設定を連携することができる。</p>
<p>spring cloud configと同様に、 <code>bootstrap.properties</code> でVaultへの接続情報を設定することで、読み込みを行うようだ。</p>
<p><code>application.yml</code> を作成してそこからの設定値読み込みと同時に使用しても問題なく使えた。
(まぁ当たり前か。)</p>
<p>RabbitだのAWSだのElasticsearchだののクレデンシャル情報に対応していると記載されているところから、 <code>bootstrap.properties</code> で操作することで、対応するミドルウェアのクレデンシャル情報を通常の <code>application.yml</code> に設定するのと同様の状態で設定することができるようだ。</p>
<hr>
<p>どのへんでうれしさを感じるのだろうか？<br>
環境変数で刺すようにするサービスブローカーとどう違うのか。。。？</p>
<p>よりアプリケーションに近い位置でクレデンシャルを設定できるので、良いような悪いような。</p>
<p>コンテナ運用の場合はコンテナ管理ミドルによって環境変数にさしてほしい気もする。</p>
<p>コンテナ管理ミドルを使わずに、手運用デプロイしているときにうれしいとか？<br>
そんな状況で（クレデンシャル管理が）いる？<br>
（そんなならば <code>application.yml</code> にべた書きしてもよいじゃないか）</p>
<p>K8Sな言葉がちょいちょい出てくるので何か想定する運用があるっぽい気もするけど、調べるの飽きてきたのでそろそろ終わる。</p>
]]></content>
		</item>
		
		<item>
			<title>もやもやボール</title>
			<link>https://pages.shibadog.net/posts/006_moyat-ball-star/</link>
			<pubDate>Sun, 28 Jun 2020 09:45:32 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/006_moyat-ball-star/</guid>
			<description>ユニット折り紙 イライラ、もやもやしたときにいつも作るユニット折り紙を並べて行こうという試み。
今回、いつも使っているユニット折り紙の本以外から情報を得て作ったので、作り方を残しておくというのもある。
完成図 作り方 思ったよりも、Draw.ioで折り紙書くの辛かった（何
折り紙の図面は表裏がわかるように範囲色付けとか、変形させた際に微調整をするために、線同士の結合をしたまま移動させるとかの機能があったほうがいい。。。
つまり、ちゃんとしたお絵かきソフトで作ったほうが断然効率がいいということが分かったorz
でもちょっと面白かった</description>
			<content type="html"><![CDATA[<h2 id="heading">ユニット折り紙</h2>
<p>イライラ、もやもやしたときにいつも作るユニット折り紙を並べて行こうという試み。</p>
<p>今回、いつも使っているユニット折り紙の本以外から情報を得て作ったので、作り方を残しておくというのもある。</p>
<h2 id="heading-1">完成図</h2>
<p><img src="./IMG_0103.jpg" alt="完成図"></p>
<h2 id="heading-2">作り方</h2>
<p><img src="./001_%E4%BD%9C%E3%82%8A%E6%96%B9.drawio.svg" alt=""></p>
<p><img src="./002_%E4%BD%9C%E3%82%8A%E6%96%B9.drawio.svg" alt=""></p>
<p><img src="./003_%E4%BD%9C%E3%82%8A%E6%96%B9.drawio.svg" alt=""></p>
<p>思ったよりも、Draw.ioで折り紙書くの辛かった（何</p>
<p>折り紙の図面は表裏がわかるように範囲色付けとか、変形させた際に微調整をするために、線同士の結合をしたまま移動させるとかの機能があったほうがいい。。。<br>
つまり、ちゃんとしたお絵かきソフトで作ったほうが断然効率がいいということが分かったorz</p>
<p>でもちょっと面白かった</p>
]]></content>
		</item>
		
		<item>
			<title>最近気持ちが上がった話</title>
			<link>https://pages.shibadog.net/posts/005_%E6%9C%80%E8%BF%91%E6%B0%97%E6%8C%81%E3%81%A1%E3%81%8C%E4%B8%8A%E3%81%8C%E3%81%A3%E3%81%9F%E8%A9%B1/</link>
			<pubDate>Sat, 20 Jun 2020 00:26:00 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/005_%E6%9C%80%E8%BF%91%E6%B0%97%E6%8C%81%E3%81%A1%E3%81%8C%E4%B8%8A%E3%81%8C%E3%81%A3%E3%81%9F%E8%A9%B1/</guid>
			<description>別にまとめる気もなく、アゲアゲになったヤツをただ並べるだけ
 Spring-bootの2.3系でmavenのビルドにbuildpackが組み込まれた  なので、ちょーーーかんたんにdocker-composeで複数アプリをホイホイ立てれるし、コード編集しつつ反映が楽ちん。   vscodeでdrawioを直いじりができつつ、pngやsvgで保存できる。  なので、ちょーーーかんたんにmarkdownに埋め込む画像をdrawioで編集しつつgithubで見れる。(hugo使った記事にも使える)   一緒にお題を決めて勉強をしてくれる人を見つけた（若い子たちだけど おいちゃんから連絡があった  あんまりなかった。。。でもマジで気分が上がったネタだった。
次は、こうだったらいいのになー
 APIのI/Fをドキュメントする便利で安定していて広く使える方法 超手軽に立てられる環境隔離ができ（Concouseみたいに）、環境構築をコードで書けるCIシステム ブラウザバージョンアップに追従しなくていいブラウザ自動操作系の何か（selenium辛い）  </description>
			<content type="html"><![CDATA[<p>別にまとめる気もなく、アゲアゲになったヤツをただ並べるだけ</p>
<ul>
<li>Spring-bootの2.3系でmavenのビルドにbuildpackが組み込まれた
<ul>
<li>なので、ちょーーーかんたんにdocker-composeで複数アプリをホイホイ立てれるし、コード編集しつつ反映が楽ちん。</li>
</ul>
</li>
<li>vscodeでdrawioを直いじりができつつ、pngやsvgで保存できる。
<ul>
<li>なので、ちょーーーかんたんにmarkdownに埋め込む画像をdrawioで編集しつつgithubで見れる。(hugo使った記事にも使える)</li>
</ul>
</li>
<li>一緒にお題を決めて勉強をしてくれる人を見つけた（若い子たちだけど</li>
<li>おいちゃんから連絡があった</li>
</ul>
<p>あんまりなかった。。。でもマジで気分が上がったネタだった。</p>
<p>次は、こうだったらいいのになー</p>
<ul>
<li>APIのI/Fをドキュメントする便利で安定していて広く使える方法</li>
<li>超手軽に立てられる環境隔離ができ（Concouseみたいに）、環境構築をコードで書けるCIシステム</li>
<li>ブラウザバージョンアップに追従しなくていいブラウザ自動操作系の何か（selenium辛い）</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>暗号化/ハッシュ化について調べた</title>
			<link>https://pages.shibadog.net/posts/003_encript/</link>
			<pubDate>Mon, 04 Nov 2019 22:54:02 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/003_encript/</guid>
			<description>何もできなかったから過去書いたネタを転載（ぉ
暗号化アルゴリズム 暗号化と複合 暗号化は誰でもアクセス可能なパブリックな場所でデータを転送する際に、第三者にデータを盗み見されたり、改ざんされないようにデータを守るために用いられる。
暗号化や複合は、暗号化アルゴリズムと鍵によって行われる。
2種類の暗号化方式 暗号化アルゴリズムには大きく分けて2種類のものがある。
 共通鍵暗号 公開鍵暗号  共通鍵暗号 この方式は、直観的に理解しやすい。
いわゆる現実で用いる「鍵」と同様の方法で、一つの「鍵」を用いて鍵をかける（暗号化）ことができ、さらに同じ「鍵」で鍵を開ける（複合化）できる。
また、この「鍵」を「共通鍵」と呼ぶ。
欠点と相手は、暗号化する側と、複合化する側が異なる場合に同一の「共通鍵」をそれぞれが保有している必要がある。
これは、「共通鍵」を他人が知り得てしまった場合は、その他人が暗号文を解読できてしまうというリスクが発生する。
公開鍵方式 この方式は、少し現実で表現しにくい。
二つの鍵を用意し、それぞれ、「暗号化用」と「複合化用」とする。
「暗号化用」の鍵を「公開鍵」と呼び、「複合化用」の鍵を「秘密鍵」と呼ぶ。
使用するときは、複合化する側が2つの鍵を生成し、「公開鍵」を暗号化する側に渡す。
渡された暗号化する側が「公開鍵」で暗号化を行った後、複合化する側に暗号文を渡す。
複合化する側は「秘密鍵」を用いて暗号文を複合化できる。
この方式の特徴は、「公開鍵」で暗号化したものは「秘密鍵」でのみ複合化できるということで、かつ、「公開鍵」を用いて「秘密鍵」を推測することができないことである。
「公開鍵」を知り得ても暗号化はできても複合化ができないため、必ず「秘密鍵」を持っているものしか暗号文を解読することはできない。
欠点としては、共通鍵方式と比べると処理（暗号化・複合化）の速度が遅い。
ハイブリット方式 それぞれの方式には利点・欠点がありそれを補完するためにはブリット方式が存在する。
ハイブリット方式では、データの暗号化には「共通鍵方式」を用い、この「共通鍵」を受け渡す際に「公開鍵方式」で暗号化を行うというものである。
「共通鍵」の漏えいリスクを「公開鍵方式」で担保し、高速な「共通鍵方式」のアルゴリズムでデータを担保するという手法。
共通鍵方式の中での2種類の方式 共通鍵方式の中で、その手法を大きく2つに分けることができる。
それが以下の2つの種類の暗号化方式である。
 ブロック暗号 ストリーム暗号  ブロック暗号 ブロック暗号は、暗号化対象の平文データを一定の長さのブロックに分割して暗号化を行う手法である。
通常、平文データは1byte単位の可変長であるが、1byteごとに1byteの暗号文としていた場合は256通りのパターンでしかないため、簡単に解読されてしまう。
これを防ぐために、8byte（64bit）や、32byte（256bit）といった、より大きな「ブロック」ごとにまとめて暗号化する方式で解読を難しくしている。
ストリーム暗号 ブロック暗号では、ブロック毎に暗号化をすることで1byte毎の暗号化よりも解読を難しくしているが、結局ブロック長が短ければパターン数が少なく解読の難易度も下がってしまう問題は変わらない。
ブロック長を十分な長さにしたとしても、過去あった暗号化方式であるDESでも起こったように、コンピュータの性能向上によって脆弱なアルゴリズムになってしまう。
そこで、任意長の鍵ストリーム列を生成させ、これと入力の平文を演算させる「ストリーム暗号」が考え出された。
これは、1bitや1byte単位でデータを暗号化でき、かつ、パターンを十分に増やせる。
また、対象の平文の長さを気にしなくて済むため、SSL（HTTPS）や無線LAN（WEP）など、ネットワークトラフィックを暗号化するために利用されている。
暗号化アルゴリズムの種類 暗号化アルゴリズム一覧    # 方式 暗号化方式 暗号アルゴリズム 信頼度 規格 備考     1 共通鍵 ブロック DES 低 RFC 2451    2 共通鍵 ブロック AES 中     3 共通鍵 ブロック Rijndael 高     4 共通鍵 ブロック Triple-DES 中     5 共通鍵 ブロック RC2 低 RFC 2268    6 共通鍵 ストリーム RC4 低 RFC 7465    7 公開鍵 - RSA 高  大きな数の素因数分解問題   8 公開鍵 - El Gamal 高  離散対数問題   9 公開鍵 - ECC 高  離散対数暗号方式に楕円曲線の点のグループを適用させた方式    暗号利用モード (Block cipher modes of opration) 暗号化のアルゴリズムとは別に、暗号化を行う手順についての規格（？）。</description>
			<content type="html"><![CDATA[<p>何もできなかったから過去書いたネタを転載（ぉ</p>
<h2 id="heading">暗号化アルゴリズム</h2>
<h3 id="heading-1">暗号化と複合</h3>
<p>暗号化は誰でもアクセス可能なパブリックな場所でデータを転送する際に、第三者にデータを盗み見されたり、改ざんされないようにデータを守るために用いられる。</p>
<p>暗号化や複合は、暗号化アルゴリズムと鍵によって行われる。</p>
<h3 id="2">2種類の暗号化方式</h3>
<p>暗号化アルゴリズムには大きく分けて2種類のものがある。</p>
<ul>
<li>共通鍵暗号</li>
<li>公開鍵暗号</li>
</ul>
<h4 id="heading-2">共通鍵暗号</h4>
<p>この方式は、直観的に理解しやすい。</p>
<p>いわゆる現実で用いる「鍵」と同様の方法で、一つの「鍵」を用いて鍵をかける（暗号化）ことができ、さらに同じ「鍵」で鍵を開ける（複合化）できる。</p>
<p>また、この「鍵」を「共通鍵」と呼ぶ。</p>
<p>欠点と相手は、暗号化する側と、複合化する側が異なる場合に同一の「共通鍵」をそれぞれが保有している必要がある。</p>
<p>これは、「共通鍵」を他人が知り得てしまった場合は、その他人が暗号文を解読できてしまうというリスクが発生する。</p>
<h4 id="heading-3">公開鍵方式</h4>
<p>この方式は、少し現実で表現しにくい。</p>
<p>二つの鍵を用意し、それぞれ、「暗号化用」と「複合化用」とする。</p>
<p>「暗号化用」の鍵を「公開鍵」と呼び、「複合化用」の鍵を「秘密鍵」と呼ぶ。</p>
<p>使用するときは、複合化する側が2つの鍵を生成し、「公開鍵」を暗号化する側に渡す。</p>
<p>渡された暗号化する側が「公開鍵」で暗号化を行った後、複合化する側に暗号文を渡す。</p>
<p>複合化する側は「秘密鍵」を用いて暗号文を複合化できる。</p>
<p>この方式の特徴は、「公開鍵」で暗号化したものは「秘密鍵」でのみ複合化できるということで、かつ、「公開鍵」を用いて「秘密鍵」を推測することができないことである。</p>
<p>「公開鍵」を知り得ても暗号化はできても複合化ができないため、必ず「秘密鍵」を持っているものしか暗号文を解読することはできない。</p>
<p>欠点としては、共通鍵方式と比べると処理（暗号化・複合化）の速度が遅い。</p>
<h3 id="heading-4">ハイブリット方式</h3>
<p>それぞれの方式には利点・欠点がありそれを補完するためにはブリット方式が存在する。</p>
<p>ハイブリット方式では、データの暗号化には「共通鍵方式」を用い、この「共通鍵」を受け渡す際に「公開鍵方式」で暗号化を行うというものである。</p>
<p>「共通鍵」の漏えいリスクを「公開鍵方式」で担保し、高速な「共通鍵方式」のアルゴリズムでデータを担保するという手法。</p>
<h3 id="2-1">共通鍵方式の中での2種類の方式</h3>
<p>共通鍵方式の中で、その手法を大きく2つに分けることができる。</p>
<p>それが以下の2つの種類の暗号化方式である。</p>
<ul>
<li>ブロック暗号</li>
<li>ストリーム暗号</li>
</ul>
<h4 id="heading-5">ブロック暗号</h4>
<p>ブロック暗号は、暗号化対象の平文データを一定の長さのブロックに分割して暗号化を行う手法である。</p>
<p>通常、平文データは1byte単位の可変長であるが、1byteごとに1byteの暗号文としていた場合は256通りのパターンでしかないため、簡単に解読されてしまう。</p>
<p>これを防ぐために、8byte（64bit）や、32byte（256bit）といった、より大きな「ブロック」ごとにまとめて暗号化する方式で解読を難しくしている。</p>
<h4 id="heading-6">ストリーム暗号</h4>
<p>ブロック暗号では、ブロック毎に暗号化をすることで1byte毎の暗号化よりも解読を難しくしているが、結局ブロック長が短ければパターン数が少なく解読の難易度も下がってしまう問題は変わらない。</p>
<p>ブロック長を十分な長さにしたとしても、過去あった暗号化方式であるDESでも起こったように、コンピュータの性能向上によって脆弱なアルゴリズムになってしまう。</p>
<p>そこで、任意長の鍵ストリーム列を生成させ、これと入力の平文を演算させる「ストリーム暗号」が考え出された。</p>
<p>これは、1bitや1byte単位でデータを暗号化でき、かつ、パターンを十分に増やせる。</p>
<p>また、対象の平文の長さを気にしなくて済むため、SSL（HTTPS）や無線LAN（WEP）など、ネットワークトラフィックを暗号化するために利用されている。</p>
<h3 id="heading-7">暗号化アルゴリズムの種類</h3>
<h4 id="heading-8">暗号化アルゴリズム一覧</h4>
<table>
<thead>
<tr>
<th>#</th>
<th>方式</th>
<th>暗号化方式</th>
<th>暗号アルゴリズム</th>
<th>信頼度</th>
<th>規格</th>
<th>備考</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>共通鍵</td>
<td>ブロック</td>
<td>DES</td>
<td>低</td>
<td>RFC 2451</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>共通鍵</td>
<td>ブロック</td>
<td>AES</td>
<td>中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>共通鍵</td>
<td>ブロック</td>
<td>Rijndael</td>
<td>高</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>共通鍵</td>
<td>ブロック</td>
<td>Triple-DES</td>
<td>中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>共通鍵</td>
<td>ブロック</td>
<td>RC2</td>
<td>低</td>
<td>RFC 2268</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>共通鍵</td>
<td>ストリーム</td>
<td>RC4</td>
<td>低</td>
<td>RFC 7465</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>公開鍵</td>
<td>-</td>
<td>RSA</td>
<td>高</td>
<td></td>
<td>大きな数の素因数分解問題</td>
</tr>
<tr>
<td>8</td>
<td>公開鍵</td>
<td>-</td>
<td>El Gamal</td>
<td>高</td>
<td></td>
<td>離散対数問題</td>
</tr>
<tr>
<td>9</td>
<td>公開鍵</td>
<td>-</td>
<td>ECC</td>
<td>高</td>
<td></td>
<td>離散対数暗号方式に楕円曲線の点のグループを適用させた方式</td>
</tr>
</tbody>
</table>
<h3 id="-block-cipher-modes-of-opration">暗号利用モード (Block cipher modes of opration)</h3>
<p>暗号化のアルゴリズムとは別に、暗号化を行う手順についての規格（？）。</p>
<p>また、このモードはブロック暗号と呼ばれる暗号方式の際に利用する。</p>
<p>代表的なECBモードといわれる方法では、鍵で平文を暗号化する際に単純に一回暗号化処理を行う。この状態では、同じ平文を同じパスワードで暗号化した場合、暗号化結果が同一になってしまうため、パターンを解析することで平文が求められてしまう。</p>
<p>これを防ぐためのやり方がそのほかのモードである。</p>
<h4 id="ecbelectronic-codebook">ECB(Electronic Codebook)モード</h4>
<p>最も単純な暗号利用モードである。
平文を決まったブロック(長さ)に分けたのち、そのブロックをそれぞれ独立して暗号化する。</p>
<p>EBCモードの欠点は、上記にも記載した通り、同じ鍵を用いた場合ある平文ブロックを暗号化した結果の暗号ブロックが常に同じになることである。</p>
<h4 id="cbccipher-block-chaining">CBC(Cipher Block Chaining)モード</h4>
<p>この方式はIBMによって考案された方式で、各ブロックの平文を前のブロックのXORをとってから暗号化させる。</p>
<p>この方法をとることによって、同一のパスワード・平文であったとしても、文脈が異なれば暗号化結果が変わる状態となる。</p>
<p>また、最初のブロックについては、前のブロックが存在しないため、代わりになるInitialization Vector(IV)という初期値を与える。</p>
<p>これは、最初のブロックに対して前のブロックの代わりになるため、ブロック長と同じ長さを指定する必要がある。</p>
<p>この方式の欠点は以下の2点があげられる。</p>
<ul>
<li>ブロックの暗号化に前のブロックの情報が必要であるため、暗号化は並列で行うことができない。</li>
<li>暗号ブロックの長さを固定化しなければならないため、対象の平文をブロック長の整数倍の長さにパディング（空白埋めなど）しなければならない。</li>
</ul>
<p>Niels FergusonおよびBruce Schneierによって推奨される二つの暗号化の一つである。</p>
<h5 id="pcbcpropagating-cipher-block-chaining">PCBC(Propagating Cipher Block Chaining)モード</h5>
<p>あまり主流ではないCBCモードの変法である。</p>
<p>CBCモードでは、前のブロックの暗号結果を次のブロックに対してXORをかけた後に鍵で暗号化をかけていたが、PCBCモードでは、前のブロックの暗号化結果とそのブロックの暗号化前の平文をXORした結果で次のブロックの平文をXORし、鍵で暗号化する。</p>
<p>特徴としては、隣接する2つの暗号文ブロックを入れ替えたとしてもそれ以降のブロックの複合に影響しないこと。</p>
<h4 id="cfbcipher-feedback">CFB(Cipher Feedback)モード</h4>
<p>CBCモードと似ているが、どちらを主として考えるかという違いのようである。</p>
<p>手順としては、IV（または前の暗号化結果）を暗号化し、その結果に次のブロックをXORして暗号化結果とする。</p>
<p>これは、CBCモードと同様に、並列処理ができない作りである。</p>
<p>また、これもCBCモードと同様だが、平文1ビットの変更で暗号文全体が変わってしまう。</p>
<p>CBCモードと比べて利点となるのは、パディング処理を行わなくともよいという点である。</p>
<h4 id="ofboutput-feedback">OFB(Output Feedback)モード</h4>
<p>CFBモードの亜種みたいなもので、次のブロックの元となる暗号化ブロックを、前のブロックでXORをかける前の暗号化ブロックを用いる。</p>
<p>利点としては、暗号化前でも前方誤り補正を適用できることのようだが、正確な意味を理解できていない。。。[TODO]</p>
<p>また、細かい部分の説明を省くが、CBCモードを入力がすべて0で実施したときの暗号化ブロックが、OFBモードのブロックごとの入力値となるため、ハードウェア的な高速CBC機構を用いてOFBモードを実施する事が可能である。</p>
<h4 id="ctrcounter">CTR(Counter)モード</h4>
<p>Counterと呼ばれる値とNonceと呼ばれる値を組み合わせ、暗号化処理をかけた結果を平文のブロックにXORすることで暗号化する。</p>
<p>Counterは単調増加であり値が重複することがなければどんな値でもよいが、1ずつ増加する値を用いることが一般的である。</p>
<p>また、この方式では暗号化・複合化ともに並列処理が行えるため、複数プロセッサと相性が良い。</p>
<p>さらに、Niels FergusonおよびBruce Schneierによって推奨される2つの暗号化の一つである。</p>
<h4 id="heading-9">その他</h4>
<ul>
<li>CTS(CipherText Stealing)</li>
<li>2DEM(2D Encryption Mode)</li>
<li>ABC(Accumulated Block Chaining)</li>
<li>IGE(Infinite Garble Extension)</li>
<li>F8@3GPP</li>
</ul>
<p>などなど</p>
<h4 id="heading-10">参考文献</h4>
<ol>
<li><a href="https://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E5%88%A9%E7%94%A8%E3%83%A2%E3%83%BC%E3%83%89">Wikipedia - 暗号利用モード</a></li>
<li><a href="http://www.triplefalcon.com/Lexicon/Encryption-Block-Mode-1.htm">triplefalcon - ブロック暗号化モード</a></li>
</ol>
<h3 id="heading-11">パディングモード</h3>
<p>暗号化モードでパディング処理が必要であるが、このパディングについても手法がいくつかある。</p>
<h4 id="nopadding">NoPadding</h4>
<p>単純で、パディングを行わないモード
これで問題ないのか？</p>
<h4 id="zerobytepadding">ZeroBytePadding</h4>
<p>ブロック長に満たない場合はNULLバイト(0x00)で埋める。
ブロック長ピッタリな場合はパディングされない。</p>
<p>このため、末尾のNULLバイトが本来生成された値の末尾なのかパディングされた値なのかを判断できない。</p>
<p>暗号化するデータにNULLバイトが含まれていない場合に用いれる。</p>
<h4 id="pkcs5-padding">PKCS#5 Padding</h4>
<p>ブロック長に満たないサイズの値を表すバイト値で足りない分を埋める。</p>
<p>不足分が変われば埋める値が変わる。</p>
<p>ブロック長がピッタリな場合は1ブロック分丸ごとパディングされる。</p>
<p><a href="https://www.ietf.org/rfc/rfc1423.txt">RFC1423</a>で規格化されている。</p>
<h4 id="pkcs7-padding">PKCS#7 Padding</h4>
<p>バイト シーケンスで構成され、各バイト シーケンスは追加される埋め込みバイトの合計数に等しいバイト数になる。</p>
<p><a href="https://tools.ietf.org/html/rfc5652">RFC5652</a>で規格化されている。</p>
<p>.NETではPKCS方式の場合このバージョンが実装されている。</p>
<p>たとえば以下の通り。</p>
<p><code>FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</code></p>
<h4 id="iso10126padding">ISO10126Padding</h4>
<p>W3Cで定義されているパディング方式</p>
<p>ランダムな値で埋める。</p>
<p>たとえば以下の通り。</p>
<p><code>FF FF FF FF FF FF FF FF FF 7 D 2A 75 EF F8 EF 07</code></p>
<h4 id="ssl3padding">SSL3Padding</h4>
<p>SSL Protocol バージョン3.0のセクション5.2.3.2(CBCブロック暗号)で規定されたパディング方式</p>
<h4 id="ansix923-padding">ANSIX923 Padding</h4>
<p>ブロック長に満たないサイズの値を表すバイトを最後につけたNULLバイト値で埋める。</p>
<p>たとえば以下の通り。</p>
<p><code>FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07</code></p>
<h4 id="heading-12">参考資料</h4>
<ol>
<li><a href="https://msdn.microsoft.com/ja-jp/library/system.security.cryptography.paddingmode(v=vs.110).aspx">MSDN - PaddingMode 列挙型</a></li>
<li><a href="http://pentan.info/doc/block_cipher.html">Pentan.info - [暗号化]ブロック暗号とは(AES/DES/Blowfish PKCS5Padding ECB/CBC IV)</a></li>
</ol>
<h3 id="heading-13">参考資料</h3>
<ol>
<li><a href="http://www.infraexpert.com/study/security4.html">ネットワークエンジニアとして - Common key cryptosystem / Public key cryptosystem</a></li>
<li><a href="http://www.atmarkit.co.jp/ait/articles/1504/27/news032.html">@IT - 第1回　暗号化の基礎</a></li>
<li><a href="http://www.mukaidono.jp/Board/infosys2000/security/firewall.htm">情報社会におけるセキュリティ - ２－４ 暗号化アルゴリズム</a></li>
</ol>
<h2 id="heading-14">ハッシュ化アルゴリズム</h2>
<p>暗号化とは似て異なる代物で、暗号化では可逆の暗号文を生成するが、ハッシュでは不可逆の暗号文（メッセージダイジェストとかフィンガープリントとか呼ぶらしい）を生成する。</p>
<p>また、可変のデータ長の平文を一定のデータ長の値を求めることができるため、チェックディジットや、パスワードの保管などに使われる。</p>
<p>使用方法から、ハッシュでは暗号化と異なった特性が求められる。</p>
<ul>
<li>ハッシュは同じハッシュ関数を通す場合は常に同じ値が求まる。</li>
<li>異なる元メッセージから同じハッシュ値が生成され <strong>にくい</strong></li>
<li>また、生成されたハッシュ値と同一のハッシュ値が生成されるメッセージを求めることが困難であること。</li>
</ul>
<h3 id="heading-15">ハッシュ化アルゴリズムの種類</h3>
<h4 id="heading-16">ハッシュ化アルゴリズム一覧</h4>
<table>
<thead>
<tr>
<th>#</th>
<th>ハッシュアルゴリズム</th>
<th>信頼度</th>
<th>規格</th>
<th>備考</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>MD5</td>
<td>低</td>
<td>RFC 1321</td>
<td>_</td>
</tr>
<tr>
<td>2</td>
<td>SHA-1</td>
<td>低</td>
<td>FIPS 180-2</td>
<td>_</td>
</tr>
<tr>
<td>3</td>
<td>SHA-2</td>
<td>高</td>
<td>FIPS 180-4</td>
<td>_</td>
</tr>
<tr>
<td>4</td>
<td>SHA-3</td>
<td>?</td>
<td></td>
<td>_</td>
</tr>
</tbody>
</table>
<h4 id="heading-17">参考資料</h4>
<ol>
<li><a href="http://sehermitage.web.fc2.com/crypto/digest.html">シニアエンジニアの庵 - ハッシュ関数</a></li>
</ol>
<h3 id="heading-18">ソルト</h3>
<p>ハッシュ化アルゴリズムの特性上、同じ平文を与えた場合常にハッシュ化された値は同じになることが保証されている。</p>
<p>この特性をついて、よく設定される平文に対応するハッシュ値をデータベース化し、これと突き合わせることによって平文を求めるという手法（レインボーテーブル）に弱いことが知られている。</p>
<p>この対策のため、平文に「ある値」をつなげた結果をハッシュ化し、「ハッシュ値」とこの「ある値」を一緒に管理するという手法がとられている。</p>
<p>この「ある値」をソルトと呼んでいる。</p>
<p>パスワードの管理であれば、パスワードを入力された後、このパスワードと保管しておいたソルトをつなげハッシュ値を求める。このハッシュ値が保管しているハッシュ値と一致していれば、入力されたパスワードが正しいと判断できる。</p>
<p>また、レインボーテーブルへの対応としては以下の要件を満たすべきである。</p>
<ul>
<li>平文ごとに異なるソルトを使う</li>
<li>ある程度の長さ（20文字程度以上）を確保する</li>
</ul>
<h3 id="heading-19">ストレッチング</h3>
<p>ストレッチングは総当たりによる解読の対策として生まれた手法。</p>
<p>ハッシュの使用目的として、処理速度は高速であることが求められるため、この高速性をついて総当たりでの平文探索を行われてしまうことがある。</p>
<p>これの対策として、あえて遅いハッシュ関数を作成するのではなく、早いハッシュ関数を何千回と繰り返すことで処理自体を遅くし、総当たりに時間がかかるようにする手法がストレッチングである。</p>
<p>ストレッチングの回数が多いほど安全性が高まるが、計算量が増えることで負荷がかかってしまう。</p>
<p>この負荷を利用してDoS攻撃に悪用されるリスクが高まってしまう。</p>
<h2 id="heading-20">参考資料</h2>
<ol>
<li><a href="http://tkengo.github.io/blog/2015/12/01/https-details/">けんごのお屋敷 - 理解してるつもりの SSL/TLS でも、もっと理解したら面白かった話</a></li>
<li><a href="http://qiita.com/chroju/items/3ddae568206b8bc3d8f9">Qiita - 暗号化とハッシュ化に関する基本的な事柄まとめ</a></li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>Hystrixを説明してみた２</title>
			<link>https://pages.shibadog.net/posts/002_hystrix_02/</link>
			<pubDate>Sat, 26 Oct 2019 13:17:15 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/002_hystrix_02/</guid>
			<description>Hystrixを説明してみた の続き
Hystrixの機能 Hystrixの機能紹介をしてみる。
 コマンド隔離 コマンドエラー検知  例外ハンドリング タイムアウトハンドリング   コマンド同時実行数制限  コマンド隔離 Hystrixではコマンドの隔離が行える。
具体的には、指定したメソッド一つが隔離対象となり、別名で隔離したメソッドと影響しあわないようにできる。
例えば、以下のように2つのコマンドを定義したアプリの場合。 コマンドAからアクセスするAPIAがタイムアウトを頻発するような状況になってしまったとすると、
コマンドAが即エラーを返すようなることで、リクエスト処理スレッドが占有されず、コマンドBは正常に処理が行われる。
コマンドエラー検知 コマンド内で実行される処理でExceptionが発生した場合には、このExceptionを検知してフォールバック処理を行うことができる。
また、コマンド内の処理のタイムアウトを測ることができ、指定時間を過ぎた場合に、HystrixのExceptionを発生させることができる。
timeInMillisecondsの秒数内に、numBuckets分の記録用の箱があるイメージ。 例えば、10,000msで10Bucketsの場合、集計範囲は1,000msになる。
circuitBreaker.errorThresholdPercentageで設定した割合でSuccess以外のエラー数となった場合に、ショートサーキット状態となる。
参考：GitHub - Netflix/Hystrix wiki
コマンド同時実行数制御 隔離されたコマンドは同時実行数の制御が行える。
Hystrixは隔離方式を2種類用意しており、デフォルトでは独立Threadによる制御を行う。
もう一つの制御方法として、セマフォ方式を持っている。
若干飽きて適当になった（ぇ
いったんこれまでにしておく。</description>
			<content type="html"><![CDATA[<p><a href="../001_hystrix_01/">Hystrixを説明してみた</a> の続き</p>
<h1 id="hystrix">Hystrixの機能</h1>
<p>Hystrixの機能紹介をしてみる。</p>
<ul>
<li>コマンド隔離</li>
<li>コマンドエラー検知
<ul>
<li>例外ハンドリング</li>
<li>タイムアウトハンドリング</li>
</ul>
</li>
<li>コマンド同時実行数制限</li>
</ul>
<h2 id="heading">コマンド隔離</h2>
<p>Hystrixではコマンドの隔離が行える。<br>
具体的には、指定したメソッド一つが隔離対象となり、別名で隔離したメソッドと影響しあわないようにできる。</p>
<p>例えば、以下のように2つのコマンドを定義したアプリの場合。
コマンドAからアクセスするAPIAがタイムアウトを頻発するような状況になってしまったとすると、<br>
コマンドAが即エラーを返すようなることで、リクエスト処理スレッドが占有されず、コマンドBは正常に処理が行われる。</p>
<!-- raw HTML omitted -->
<h2 id="heading-1">コマンドエラー検知</h2>
<p>コマンド内で実行される処理でExceptionが発生した場合には、このExceptionを検知してフォールバック処理を行うことができる。</p>
<p>また、コマンド内の処理のタイムアウトを測ることができ、指定時間を過ぎた場合に、HystrixのExceptionを発生させることができる。</p>
<p>timeInMillisecondsの秒数内に、numBuckets分の記録用の箱があるイメージ。
例えば、10,000msで10Bucketsの場合、集計範囲は1,000msになる。</p>
<p>circuitBreaker.errorThresholdPercentageで設定した割合でSuccess以外のエラー数となった場合に、ショートサーキット状態となる。</p>
<p><img src="./Hystrix%E3%82%A8%E3%83%A9%E3%83%BC%E6%A4%9C%E7%9F%A5.svg" alt=""></p>
<p>参考：<a href="https://github.com/Netflix/Hystrix/wiki/Configuration#metricsrollingstatstimeinmilliseconds">GitHub - Netflix/Hystrix wiki</a></p>
<h2 id="heading-2">コマンド同時実行数制御</h2>
<p>隔離されたコマンドは同時実行数の制御が行える。</p>
<p>Hystrixは隔離方式を2種類用意しており、デフォルトでは独立Threadによる制御を行う。</p>
<p><img src="./Hystrix%E5%90%8C%E6%99%82%E5%AE%9F%E8%A1%8C%E6%95%B0_01.svg" alt=""></p>
<p>もう一つの制御方法として、セマフォ方式を持っている。</p>
<p><img src="./Hystrix%E5%90%8C%E6%99%82%E5%AE%9F%E8%A1%8C%E6%95%B0_02.svg" alt=""></p>
<p>若干飽きて適当になった（ぇ</p>
<p>いったんこれまでにしておく。</p>
]]></content>
		</item>
		
		<item>
			<title>Hystrixを説明してみた</title>
			<link>https://pages.shibadog.net/posts/001_hystrix_01/</link>
			<pubDate>Sun, 20 Oct 2019 21:10:22 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/001_hystrix_01/</guid>
			<description>Hystrixとは Netflixが開発したOSSで、Circuit Breakerの実装。
Circuit Breakerとは、マイクロサービスで開発されたアプリケーション同士が、一つのアプリの障害で連鎖的に障害を発生させる状態を防止するための、ブレーカー的役割をする機能のこと。
後続のアプリケーションが障害を起こした場合、当該アプリで即エラーを返すことでリクエストの流入を抑える。
例えば、一番後続のアプリが障害を起こして、応答がなくなる。
リクエストが流れ続けるため、障害を起こしたアプリを呼び出す前段のアプリが引きずられ、スレッド枯渇やGC頻発による応答不能が発生する（ことがある）。
さらに、これを呼び出すアプリが同様に障害を起こすことで、正常なアプリへの呼び出しも行われなくなり、全体が障害となってしまう。
もし、Hystrixがアプリに組み込まれていた場合。
やはり、最下層のアプリに障害が発生し。。。
しかし、前段のアプリで、障害を検知して後続が障害の場合のロジックを通って
これによって、後続が障害により連続でエラーを返す状態になった場合にも、後続へのリクエストを中止し、負荷をかけないようにしたうえで、異常状態の対処を行う。
これが相当に便利であり、しかも後続への無駄な負荷をかけずにすむという代物でした。
今回はここまで。</description>
			<content type="html"><![CDATA[<h2 id="hystrix">Hystrixとは</h2>
<p>Netflixが開発したOSSで、Circuit Breakerの実装。<br>
Circuit Breakerとは、マイクロサービスで開発されたアプリケーション同士が、一つのアプリの障害で連鎖的に障害を発生させる状態を防止するための、ブレーカー的役割をする機能のこと。</p>
<p>後続のアプリケーションが障害を起こした場合、当該アプリで即エラーを返すことでリクエストの流入を抑える。</p>
<p><img src="./CircuitBreaker_01.svg" alt=""></p>
<p>例えば、一番後続のアプリが障害を起こして、応答がなくなる。</p>
<p><img src="./CircuitBreaker_02.svg" alt=""></p>
<p>リクエストが流れ続けるため、障害を起こしたアプリを呼び出す前段のアプリが引きずられ、スレッド枯渇やGC頻発による応答不能が発生する（ことがある）。</p>
<p><img src="./CircuitBreaker_03.svg" alt=""></p>
<p>さらに、これを呼び出すアプリが同様に障害を起こすことで、正常なアプリへの呼び出しも行われなくなり、全体が障害となってしまう。</p>
<p><img src="./CircuitBreaker_04.svg" alt=""></p>
<p>もし、Hystrixがアプリに組み込まれていた場合。</p>
<p><img src="./CircuitBreaker_05.svg" alt=""></p>
<p>やはり、最下層のアプリに障害が発生し。。。</p>
<p><img src="./CircuitBreaker_06.svg" alt=""></p>
<p>しかし、前段のアプリで、障害を検知して後続が障害の場合のロジックを通って</p>
<p><img src="./CircuitBreaker_07.svg" alt=""></p>
<p>これによって、後続が障害により連続でエラーを返す状態になった場合にも、後続へのリクエストを中止し、負荷をかけないようにしたうえで、異常状態の対処を行う。</p>
<p>これが相当に便利であり、しかも後続への無駄な負荷をかけずにすむという代物でした。</p>
<p>今回はここまで。</p>
]]></content>
		</item>
		
		<item>
			<title>hugoにgoogleアナリティクスを導入</title>
			<link>https://pages.shibadog.net/posts/hugo_analytics/</link>
			<pubDate>Thu, 17 Oct 2019 09:55:20 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/hugo_analytics/</guid>
			<description>とりあえずgoogle analyticsが標準対応との記述を公式ドキュメントで見つけたのでやっておく。
1. google analyticsにログイン 2. 新規プロパティを作成 ハマったこと ウェブを選択。
アプリとウェブだとうまくできなかった（よくよめよ）
3. トラッキングIDをコピー プロパティのメニューから選ぶ
4. config.toml に追加 baseURL = &amp;#34;https://shibadog.github.io/&amp;#34; languageCode = &amp;#34;ja-jp&amp;#34; title = &amp;#34;shibadog site&amp;#34; theme = &amp;#34;hermit&amp;#34; googleAnalytics = &amp;#34;UA-999999999-9&amp;#34; [author] name = &amp;#34;shibadog&amp;#34; : : 参考  AGO&#39;s page - hugoにgoogle アナリティクスを導入した話 なかけんのHugoノート - 画像を追加しよう  </description>
			<content type="html"><![CDATA[<p>とりあえずgoogle analyticsが標準対応との記述を<a href="https://gohugo.io/templates/internal/#google-analytics">公式ドキュメント</a>で見つけたのでやっておく。</p>
<h2 id="1-google-analytics">1. google analyticsにログイン</h2>
<h2 id="2-">2. 新規プロパティを作成</h2>
<p><img src="./image1.png" alt="プロパティの種類"></p>
<h3 id="heading">ハマったこと</h3>
<p>ウェブを選択。<br>
アプリとウェブだとうまくできなかった（よくよめよ）</p>
<h2 id="3-id">3. トラッキングIDをコピー</h2>
<p>プロパティのメニューから選ぶ</p>
<p><img src="./image2.png" alt="トラッキングIDの場所"></p>
<h2 id="4-configtoml-">4. <code>config.toml</code> に追加</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-config.toml" data-lang="config.toml"><span style="color:#a6e22e">baseURL</span> = <span style="color:#e6db74">&#34;https://shibadog.github.io/&#34;</span>
<span style="color:#a6e22e">languageCode</span> = <span style="color:#e6db74">&#34;ja-jp&#34;</span>
<span style="color:#a6e22e">title</span> = <span style="color:#e6db74">&#34;shibadog site&#34;</span>
<span style="color:#a6e22e">theme</span> = <span style="color:#e6db74">&#34;hermit&#34;</span>

<span style="color:#a6e22e">googleAnalytics</span> = <span style="color:#e6db74">&#34;UA-999999999-9&#34;</span>

[<span style="color:#a6e22e">author</span>]
  <span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;shibadog&#34;</span>
<span style="color:#960050;background-color:#1e0010">:</span>
<span style="color:#960050;background-color:#1e0010">:</span>
</code></pre></div><h2 id="heading-1">参考</h2>
<ul>
<li><a href="https://agodoriru.github.io/post/20171218/">AGO's page - hugoにgoogle アナリティクスを導入した話</a></li>
<li><a href="https://hugo.nakaken88.com/use/image/">なかけんのHugoノート - 画像を追加しよう</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>ブログのネタブログ</title>
			<link>https://pages.shibadog.net/posts/blog_neta/</link>
			<pubDate>Wed, 16 Oct 2019 22:12:21 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/blog_neta/</guid>
			<description>ブログを書きたい気持ちはある。（ともにネタもいくつか考えられはする）
がしかし、どこから攻めるか、はたまた思いつくままに初めて尻すぼみで終わるのではないかという不安がある。
これの対策として、ブログにしたい（つまり勉強したい）ネタを並べて置くことにする。
（つまり、「今興味があること」になるわけだ）
 Java系  Hystrix（というはサーキットブレーカー）についての動き説明 Resilience4jの動きの調査 Spring Boot サーキットブレーカーの調査 WebClient系の動き調査 リトライ系の動きの調査 Spring以外のフレームワーク（Javaに限る）の調査   インフラ寄り  くーばねーちすの調査 DockerとDocker Compose周り。あと運用。 TCP/IPやHTTPとかSSLとか   他ジャンル  らずぱい hugoのカスタマイズ・使いこなし系の話   アルゴリズム  暗号化まわり 圧縮回り GCアルゴリズム    次に、書こうと思っていつも断念する原因の調査（これをしないと進めない気がするから）
なぜ、ブログを書こうとして不安に陥るのか？
 調べると世の中大体、誰かが同じようなことをしている  でも、複数の情報を合わせないと目的のものにならない 結局自分の言葉にしないと理解が進まない よし、OK   自分が書くより他人が書いたもののほうがわかりやすいし正確  結局自分の言葉にしないと理解が進まない 間違っていることに気づいたら直せばよい。 よし、OK   ディテールにこだわってなかなか完成しない  調査内容にコンセプトを作り、小さく初めて積み上げる！ 途中まで進めてもいいんだよ、間違っていると感じたらやり直せばよいじゃないか。 よし、OK   誰の役にも立たないでしょう？すでにあるわけだし正確でもなく不十分だったりするわけだから  やらないよりはやったほうが良い。 少なくとも自分のためにはなるはず よし、OK    不安になったら見直そう。</description>
			<content type="html"><![CDATA[<p>ブログを書きたい気持ちはある。（ともにネタもいくつか考えられはする）<br>
がしかし、どこから攻めるか、はたまた思いつくままに初めて尻すぼみで終わるのではないかという不安がある。</p>
<p>これの対策として、ブログにしたい（つまり勉強したい）ネタを並べて置くことにする。<br>
（つまり、「今興味があること」になるわけだ）</p>
<ul>
<li>Java系
<ul>
<li>Hystrix（というはサーキットブレーカー）についての動き説明</li>
<li>Resilience4jの動きの調査</li>
<li>Spring Boot サーキットブレーカーの調査</li>
<li>WebClient系の動き調査</li>
<li>リトライ系の動きの調査</li>
<li>Spring以外のフレームワーク（Javaに限る）の調査</li>
</ul>
</li>
<li>インフラ寄り
<ul>
<li>くーばねーちすの調査</li>
<li>DockerとDocker Compose周り。あと運用。</li>
<li>TCP/IPやHTTPとかSSLとか</li>
</ul>
</li>
<li>他ジャンル
<ul>
<li>らずぱい</li>
<li>hugoのカスタマイズ・使いこなし系の話</li>
</ul>
</li>
<li>アルゴリズム
<ul>
<li>暗号化まわり</li>
<li>圧縮回り</li>
<li>GCアルゴリズム</li>
</ul>
</li>
</ul>
<p>次に、書こうと思っていつも断念する原因の調査（これをしないと進めない気がするから）<br>
なぜ、ブログを書こうとして不安に陥るのか？</p>
<ul>
<li>調べると世の中大体、誰かが同じようなことをしている
<ul>
<li>でも、複数の情報を合わせないと目的のものにならない</li>
<li>結局自分の言葉にしないと理解が進まない</li>
<li>よし、OK</li>
</ul>
</li>
<li>自分が書くより他人が書いたもののほうがわかりやすいし正確
<ul>
<li>結局自分の言葉にしないと理解が進まない</li>
<li>間違っていることに気づいたら直せばよい。</li>
<li>よし、OK</li>
</ul>
</li>
<li>ディテールにこだわってなかなか完成しない
<ul>
<li>調査内容にコンセプトを作り、小さく初めて積み上げる！</li>
<li>途中まで進めてもいいんだよ、間違っていると感じたらやり直せばよいじゃないか。</li>
<li>よし、OK</li>
</ul>
</li>
<li>誰の役にも立たないでしょう？すでにあるわけだし正確でもなく不十分だったりするわけだから
<ul>
<li>やらないよりはやったほうが良い。</li>
<li>少なくとも自分のためにはなるはず</li>
<li>よし、OK</li>
</ul>
</li>
</ul>
<p>不安になったら見直そう。</p>
<p>あと、大得意の3日坊主にならないために、一週間に一回は何かしらを進めるようにしよう。
そして途中でもここに書き留めていこうと心に決める（ほんとかよ）</p>
]]></content>
		</item>
		
		<item>
			<title>My First Post</title>
			<link>https://pages.shibadog.net/posts/my-first-post/</link>
			<pubDate>Tue, 15 Oct 2019 23:52:59 +0900</pubDate>
			
			<guid>https://pages.shibadog.net/posts/my-first-post/</guid>
			<description>ブログをまたやりたいと思い、 Hugo という静的サイトジェネレータと GitHub Pages を使って作ってみた。
3日坊主にならないことを祈る。
しかし、このHugoというやつ結構楽しい。 まずはこれを使いこなせるようになりたい。。。</description>
			<content type="html"><![CDATA[<p>ブログをまたやりたいと思い、 <code>Hugo</code> という静的サイトジェネレータと <code>GitHub Pages</code> を使って作ってみた。</p>
<p>3日坊主にならないことを祈る。</p>
<p>しかし、このHugoというやつ結構楽しい。
まずはこれを使いこなせるようになりたい。。。</p>
]]></content>
		</item>
		
	</channel>
</rss>
